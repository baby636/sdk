<h1 id='code'>Code</h1>
<p>Run supports interactive code on Bitcoin. Just like you can own jig objects, you can deploy and own JavaScript classes and functions too. We call these on-chain classes and functions <a href="#api-reference-code">Code</a> with a capital C. Using Code, you can define new kinds of jigs, create reusable helper functions, share your server logic for auditability, discover algorithms from other apps, and much more. In fact, did you know you&#39;ve already been using Code? Every jig object requires a jig class, which is Code! Code is the foundation for jigs, but you&#39;ll see that it also useful in its own right.</p>

<p>There are two major kinds of Code: <em>jig code</em> and <em>sidekicks</em>. Jig code are classes that extend from <a href="#api-reference-jig">Jig</a> and are themselves jigs. You can use them to create jig objects as we&#39;ve already seen, but you can also call methods to record updates to them on the blockchain. These evolve over time according to same <a href="#how-it-works-ownership-rules">jig ownership rules</a> as objects. Sidekicks are your helpers. They are classes or functions that don&#39;t extend from <code>Jig</code> and are used instead for more supporting roles. When you call a method on a sidekick, nothing gets recorded on-chain. But you can use sidekicks inside jigs and even your own app. Using jig code and sidekicks, you have a powerful repertoire for building extensible apps.</p>
<h2 id='code-deploying'>Deploying</h2>
<blockquote>
<p>Deploy a jig class with a dependency</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">Reward</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="kr">class</span> <span class="nx">LootBox</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span>
  <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">reward</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Reward</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">LootBox</span><span class="p">.</span><span class="nx">deps</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">Reward</span> <span class="p">}</span>

<span class="kr">const</span> <span class="nx">LootBoxCode</span> <span class="o">=</span> <span class="nx">run</span><span class="p">.</span><span class="nx">deploy</span><span class="p">(</span><span class="nx">LootBox</span><span class="p">)</span>
<span class="nx">await</span> <span class="nx">LootBoxCode</span><span class="p">.</span><span class="nx">sync</span><span class="p">()</span>
</code></pre>
<blockquote>
<p>Deploy a sidekick function</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kd">function</span> <span class="nx">sha256</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="nx">run</span><span class="p">.</span><span class="nx">deploy</span><span class="p">(</span><span class="nx">sha256</span><span class="p">)</span>
<span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">sync</span><span class="p">()</span>
</code></pre>
<p>To upload your class or function to Bitcoin, you <em>deploy</em> it. Call <code>run.deploy</code> and pass in your local class or function. Run will publish a new Bitcoin transaction that assigns your code a location and makes you the owner. Being the owner allows you to perform actions using the code. Code is not always static, as we&#39;ll see!</p>

<p>When <code>deploy</code> returns, it returns to you the Code version of your class or function. This Code version looks just like your original class or function, except that it is securely sandboxed, and it gets various Code methods and properties that allow you to use it on the blockchain. You can call <code>sync()</code> on it right away to make sure that it deployed successfully.</p>

<p>Because Code you deploy is sandboxed, you have to tell Run about any dependencies. If you use another class or function in code, tell Run about it by setting the <code>deps</code> property, as seen to the right. Run will link the two types together on-chain when they are deployed.</p>

<p>We recommend you deploy all of your code in advance so your users and your app have a stable library to work with. You can either do this yourself using a script, or give the <a href="#tools-deploy">Deploy Tool</a> a try.</p>
<h2 id='code-loading'>Loading</h2>
<blockquote>
<p>Load the Data class from another instance</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">Data</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="s1">'&lt;class-location-goes-here&gt;'</span><span class="p">)</span>

<span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">(</span><span class="s1">'abc'</span><span class="p">)</span>
</code></pre>
<blockquote>
<p>Find a class you own in the inventory</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">inventory</span><span class="p">.</span><span class="nx">sync</span><span class="p">()</span>

<span class="kr">const</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="nx">run</span><span class="p">.</span><span class="nx">inventory</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">C</span> <span class="o">=&gt;</span> <span class="nx">C</span><span class="p">.</span><span class="nx">origin</span> <span class="o">===</span> <span class="nx">myClassOrigin</span><span class="p">)</span>
</code></pre>
<p>You may wish to download and use code that has already been deployed. For example, you might create instances of a particular jig class, or use code from third-parties in your application like a more secure NPM. <code>run.load</code>, in addition to loading jigs, is also able to download, install and sandbox Code from the blockchain. Simply pass in the location of the code you wish to download.</p>

<p>Alternatively, <code>run.inventory.sync()</code> will load all of Code that you own and place it in the <code>run.inventory.code</code> array. You can filter that array to find the code you want to use. Be careful not to filter code by name though! Because anyone can create Code with any name and send it to you.</p>
<h2 id='code-extending'>Extending</h2><pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">EditablePost</span> <span class="kr">extends</span> <span class="nx">Post</span> <span class="p">{</span>
  <span class="nx">edit</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>You can extend classes to add or change behavior. This is especially useful for jigs, when you might want to create a hierarchy of related types! Think for example a game where a base Weapon class is extended to create many types of weapons. Subclasses can use <code>super</code> to call parent methods just as you would in normal JavaScript classes too.</p>

<p>By default, extending code requires its owner&#39;s approval. This ensures <code>instanceof</code> is secure! Because if you didn&#39;t require owner approval, third-parties could extend from a class to bypass your <code>instanceof</code> checks. However, sometimes you may want third-parties to extend from you. In that case, set the <code>sealed</code> property to <code>false</code> before you deploy. This will allow anyone to extend from your class.</p>
<h2 id='code-syncing'>Syncing</h2>
<blockquote>
<p>Load a jig class using its origin and sync it to the latest state</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">DigitalPet</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="s1">'&lt;digital-pet-class-origin&gt;'</span><span class="p">)</span>

<span class="nx">await</span> <span class="nx">DigitalPet</span><span class="p">.</span><span class="nx">sync</span><span class="p">()</span>
</code></pre>
<p>When you call <code>code.sync()</code>, it works just like <code>jig.sync()</code>. If there are pending transactions, they will be published to the blockchain, and if there are network updates you haven&#39;t received, Run will download and apply them. We always recommend calling <code>sync()</code> after every code update catch errors too. For more, see <a href="#api-reference-jigs-syncing">Jigs: Syncing</a>. If you load a class by its origin, it is best to call <code>sync()</code> right after to make sure you have the latest state.</p>
<h2 id='code-updating'>Updating</h2><pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">Weapon</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">setPower</span><span class="p">(</span><span class="nx">power</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">power</span> <span class="o">=</span> <span class="nx">power</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">WeaponCode</span> <span class="o">=</span> <span class="nx">run</span><span class="p">.</span><span class="nx">deploy</span><span class="p">(</span><span class="nx">Weapon</span><span class="p">)</span>

<span class="nx">WeaponCode</span><span class="p">.</span><span class="nx">setPower</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="c1">// WeaponCode.power === 100</span>
</code></pre>
<p>Code can evolve over time just like jig objects. It is important to think of Code as living objects with their own history. Both jig and sidekick code can be upgraded, destroyed, and authed. Every time some Code is updated, Run publishes a Bitcoin transaction with the update and assigns it a new location. Other jigs that use your Code will see your updates when they sync their jigs.</p>

<p>With a jig class, you can also call methods to change its properties. To write a jig class method, just put <code>static</code> before the method name and it will apply to the class itself, as seen on the right. You can use this to change properties, call other class methods, and create instances. You can even change the owner to send the code to someone else!</p>
<h2 id='code-upgrading'>Upgrading</h2><pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">WeaponCode</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="s1">'&lt;weapon-class-location&gt;'</span><span class="p">)</span>

<span class="kr">class</span> <span class="nx">Weapon</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="nx">WeaponCode</span><span class="p">.</span><span class="nx">upgrade</span><span class="p">(</span><span class="nx">Weapon</span><span class="p">)</span>

<span class="nx">await</span> <span class="nx">WeaponCode</span><span class="p">.</span><span class="nx">sync</span><span class="p">()</span>
</code></pre>
<p>After your code is deployed, you may discover that it is missing an important feature or that it has a bug. In other blockchains, this is a terminal failure! But in Run, you can call <code>upgrade()</code> on your Code and pass in a replacement class or function. That replacement will become the new code. You can use this to add new functionality, fix bugs, or change rules over time. Make sure that all methods and properties you want are still on the new code, just as if you deployed it for the first time!</p>

<p>When other jigs or code that use your code are synced, your upgrades will be automatically applied. You cannot change past behavior though; you can only change the future.</p>

<p>If you wish to provably prevent upgrades, you can set <code>upgradable</code> to false on the class. This is useful if you wish to show others that your code will not fundamentally change.</p>

<p>With great power comes great responsibility! Be careful.</p>
