<h1 id='how-it-works'>How It Works</h1><h2 id='how-it-works-overview'>Overview</h2>
<p>A jig is a JavaScript object that Run syncs with the blockchain. All of its code and method calls are stored on-chain in <code>op_return</code> metadata. Run can reconstruct the state of jigs by loading the code and replaying every method call. Every jig is paired with a Bitcoin output and only the owner of that output can make changes to the jig. All updates taken together form a transaction chain that enables consensus through user verification. This design is similar to other Layer-2 UTXO-based token systems because miners don&#39;t verify the JavaScript code. If anyone publishes an incorrect update, it not only destroys the jig but also leaves an immutable record.</p>
<h2 id='how-it-works-transaction'>Transaction</h2>
<blockquote>
<p>Sample code for a transaction</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">Dragon</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span> <span class="p">}</span>

<span class="kr">const</span> <span class="nx">dragon</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dragon</span><span class="p">()</span>
</code></pre>
<p>A transaction in Run is an atomic update to jigs or code.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inputs -&gt; Computation -&gt; Outputs</p>

<p>Inputs are the jigs and code which will be updated. Computation is stored as executable statements in an <code>op_return</code>. The Run Virtual Machine executes these statements and produces outputs which are the jigs and code updated or created fresh. There may also be payment inputs and outputs too that are not used by Run but part of the transaction. Here is the transaction format for the example to the right:</p>

<table><thead>
<tr>
<th>Inputs</th>
<th>Outputs</th>
</tr>
</thead><tbody>
<tr>
<td>1. payment</td>
<td>1. op_return: Run metadata</td>
</tr>
<tr>
<td></td>
<td>2. p2pkh: Dragon Class</td>
</tr>
<tr>
<td></td>
<td>3. p2pkh: dragon jig instance</td>
</tr>
<tr>
<td></td>
<td>4. change output for payment</td>
</tr>
</tbody></table>

<blockquote>
<p>Inspecting Run metadata</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">rawtx</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">blockchain</span><span class="p">.</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">txid</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">metadata</span> <span class="o">=</span> <span class="nx">Run</span><span class="p">.</span><span class="nx">util</span><span class="p">.</span><span class="nx">metadata</span><span class="p">(</span><span class="nx">rawtx</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">metadata</span><span class="p">)</span>
</code></pre>
<p>The <code>op_return</code> data is made up of both push data and a JSON payload. It has the following structure:</p>

<p><code>[op_false] [op_return] &#39;run&#39; &lt;version&gt; &#39;&lt;app-id&gt;&#39; &#39;&lt;json-payload&gt;&#39;</code></p>

<ul>
<li>Each data field starts with an <code>op_push</code> specifying its length.</li>
<li>The protocol version is currently 0x05.</li>
<li>The <code>app-id</code> field enables applications to identify their Run transactions.</li>
<li>Strings are UTF-8 encoded.</li>
<li><code>[op_false] [op_return]</code> is the standard prefix for metadata on Bitcoin SV since the Quasar hard fork.</li>
</ul>

<p>You can easily identify Run transactions and its outputs using the <code>op_return</code> metadata.</p>
<h2 id='how-it-works-json-payload'>JSON Payload</h2>
<blockquote>
<p>Sample JSON payload</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="p">{</span>
    <span class="s2">"in"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s2">"ref"</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">"native://Jig"</span>
    <span class="p">],</span>
    <span class="s2">"out"</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">"e494cd3d0c33615620c22f44cddf85f2bf613fd608dbfc53822664581205d198"</span><span class="p">,</span>
        <span class="s2">"9a99596f417e8925cb25f2acf99abe28f014aaad47ce93c427ee3afd3bcc5084"</span>
    <span class="p">],</span>
    <span class="s2">"del"</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">"cre"</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">"mhhHzeLjRTD4cjuygJFjqmCHCFpDKGrp75"</span><span class="p">,</span>
        <span class="s2">"mhhHzeLjRTD4cjuygJFjqmCHCFpDKGrp75"</span>
    <span class="p">],</span>
    <span class="s2">"exec"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">"op"</span><span class="p">:</span> <span class="s2">"DEPLOY"</span><span class="p">,</span>
            <span class="s2">"data"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"class Dragon extends Jig { }"</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"deps"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"Jig"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"$jig"</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}]</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">"op"</span><span class="p">:</span> <span class="s2">"NEW"</span><span class="p">,</span>
            <span class="s2">"data"</span><span class="p">:</span> <span class="p">[{</span> <span class="s2">"$jig"</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">[]]</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>The JSON payload stores Run-specific metadata. To the right is a JSON payload for the example above. Its fields are:</p>

<table><thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>in</td>
<td>Number of jig and code inputs</td>
</tr>
<tr>
<td>ref</td>
<td>Array of references to jigs and code used by not spent</td>
</tr>
<tr>
<td>out</td>
<td>State hashes of jigs and code in transaction outputs</td>
</tr>
<tr>
<td>del</td>
<td>State hashes of jigs and code deleted</td>
</tr>
<tr>
<td>cre</td>
<td>New owners of jigs and code created</td>
</tr>
<tr>
<td>exec</td>
<td>Statements to execute on the jigs</td>
</tr>
</tbody></table>

<p>The <code>exec</code> field in particular contains the statements for Run to execute. There are 4 opcodes supported by Run in 0.6:</p>

<table><thead>
<tr>
<th>Opcode</th>
<th>Description</th>
<th>Data Format</th>
</tr>
</thead><tbody>
<tr>
<td>DEPLOY</td>
<td>Upload new code</td>
<td><code>[&lt;src1&gt;, &lt;props1&gt;, &lt;src2&gt;, &lt;props2&gt;, ...]</code></td>
</tr>
<tr>
<td>NEW</td>
<td>Instantiate a jig</td>
<td><code>[&lt;jig class&gt;, &lt;args&gt;]</code></td>
</tr>
<tr>
<td>CALL</td>
<td>Call a method on a jig</td>
<td><code>[&lt;jig&gt;, &lt;method&gt;, &lt;args&gt;]</code></td>
</tr>
<tr>
<td>UPGRADE</td>
<td>Replace code with new code</td>
<td><code>[&lt;code&gt;, &lt;src&gt;, &lt;props&gt;]</code></td>
</tr>
</tbody></table>

<p>The state hashes used in the <code>out</code> and <code>del</code> arrays are calculated by taking the sha-256 of the JSON serialization of the jigs. This state cache format will also be documented soon.  Finally, the Run VM provides certain <em>native</em> classes, like <code>Jig</code> and <code>Code</code>, that are built-in to its virtual machine. Eventually this virtual machine will be stored on-chain too ensuring total trustlessness.</p>

<p>The protocol will be documented more in a coming spec. Reach out for any questions!</p>
<h2 id='how-it-works-serialization'>Serialization</h2>
<blockquote>
<p>Pass a sidekick object in by value</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">creationDate</span><span class="p">,</span> <span class="nx">profilePicture</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">creationDate</span> <span class="o">=</span> <span class="nx">creationDate</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">profilePicture</span> <span class="o">=</span> <span class="nx">profilePicture</span>
    <span class="p">}</span>

    <span class="nx">valid</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">SocialGroup</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">members</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">}</span>

    <span class="nx">add</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">person</span><span class="p">).</span><span class="nx">toBeInstanceOf</span><span class="p">(</span><span class="nx">Person</span><span class="p">)</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">valid</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">members</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">SocialGroup</span><span class="p">.</span><span class="nx">deps</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">Person</span><span class="p">,</span> <span class="nx">expect</span> <span class="p">}</span>

<span class="kr">const</span> <span class="nx">group</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SocialGroup</span><span class="p">()</span>

<span class="nx">group</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'Li'</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="kc">null</span><span class="p">))</span>
</code></pre>
<p>Every jig, every argument to a method, and every static property of a class, must be serialized so that it can be restored later. Run uses a custom serialization format that is similar to JSON. The following data types are supported:</p>

<ul>
<li>Numbers (IEEE-754)</li>
<li>Strings (UTF-8)</li>
<li>Booleans</li>
<li>Objects (Basic and Sidekicks)</li>
<li>Null and Undefined</li>
<li>Arrays</li>
<li>Uint8Arrays</li>
<li>Maps</li>
<li>Sets</li>
<li>Jigs</li>
<li>Code</li>
<li>Berries</li>
</ul>

<p>All JavaScript IEEE 754 numbers types are serializable, including Infinity, NaN, and -0. Properties may be safely set on Sets, Maps, and Arrays, including any of the above types. Circular references are OK. </p>

<p>Symbols are not however serializable and will not be supported. Other JavaScript objects that are not currently supported include Date, WeakMap, Promise, Error, Float32Array, and BigInt.</p>

<p><em>Sidekick objects</em> are JavaScript objects whose constructor is a sidekick class. Whereas jigs have blockchain locations and owners, and Run enforces that their state progresses from their method calls, sidekick objects are much simpler. They are stored by-value in their current state. A lock instance is an example of a sidekick object. In effect, they are data blobs with methods from on-chain code.</p>
<h2 id='how-it-works-sandboxing'>Sandboxing</h2>
<p>All Code is sandboxed so that it does not have access to your application code, including your private keys! This provides security and also determinism when replaying a jig&#39;s history because a jig should evaluate the same in every environment. Run uses <a href="https://github.com/Agoric/ses-shim">Agoric SES</a>, the gold standard in secure JavaScript evalution, combined with the <code>vm</code> library in node and hidden <code>iframes</code> in the browser, to perform this sandboxing. Despite this, it is recommended you avoid running untrusted code.</p>
<h2 id='how-it-works-safety-checks'>Safety Checks</h2>
<p>Run also protects you from performing updates on your jigs that will not be valid by others. For example, Run will throw an error if you try to change a property on a jig directly rather than call a method, or if you attempt to set a function as a property on a jig. Only top-level method calls may change a jig&#39;s state which is also enforced by Run. In addition, every Run transaction is pre-verified before it is published on your local machine.</p>
<h2 id='how-it-works-ownership-rules'>Ownership Rules</h2>
<p>Jigs are special objects that have ownership rules which Run enforces. These include:</p>

<ul>
<li>Ownership grants the right to change the jig’s state through an action.</li>
<li>Ownership grants the right to create new jigs from the jig, where those new jigs have the same owner as the creator jig.</li>
<li>Ownership grants the right to enact actions on other jigs from the jig that change the states of those other jigs, as long as the owners of those changed jigs approve.</li>
</ul>

<p>Likewise, without ownership, the above actions cannot be performed. Proving ownership requires spending a Bitcoin output, so when ownership changes on a jig, further updates to that jig must occur in a new transaction. There is also a fourth rule of ownership that is a right granted to all jigs:</p>

<ul>
<li>A jig may reference or read the state of another jig with or without its owner’s approval.</li>
</ul>
<h2 id='how-it-works-privacy'>Privacy</h2>
<p>All jigs and jig code are stored on-chain and are open for everyone to read. This enables anyone to reconstruct the state of any jig. Privacy is achieved similar to Bitcoin UTXOs. For maximum privacy, public keys should not be re-used. In the future, we will introduce <em>private jigs</em> that are visible only to the current owners, but by their nature, they will not work as well with explorers, analytics and other services.</p>
<h2 id='how-it-works-backwards-compatibility'>Backwards Compatibility</h2>
<p>Starting in Run 0.6, which uses protocol 0x05, all jigs will be backwards-compatible. This means jigs you launch today will always be supported into the future by the Run library. This is our promise and we have taken multiple steps to ensure it. Every jig is connected to its protocol version, so as Run is updated, older jigs can be kept operational with their original behavior. In addition, we run tests on on-chain jigs with every update to ensure that your jigs continue to work.</p>
